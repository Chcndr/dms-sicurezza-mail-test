name: ğŸ“¬ Poll Email Replies

on:
  schedule:
    # Esegui ogni 5 minuti
    - cron: '*/5 * * * *'
  workflow_dispatch:
    inputs:
      force_check:
        description: 'Forza controllo immediato'
        required: false
        default: 'true'
        type: boolean

permissions:
  contents: write

jobs:
  poll-replies:
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: ğŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: ğŸ“¦ Install dependencies
      run: |
        echo "âœ… Tutti i moduli necessari sono giÃ  inclusi in Python standard library"
        
    - name: ğŸ“¬ Check for email replies
      env:
        IMAP_HOST: ${{ secrets.IMAP_HOST }}
        IMAP_USER: ${{ secrets.IMAP_USER }}
        IMAP_PASS: ${{ secrets.IMAP_PASS }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python3 << 'EOF'
        import imaplib
        import email
        import json
        import re
        import os
        from datetime import datetime, timedelta
        from email.header import decode_header
        
        # Configurazione IMAP (PostaSSL)
        imap_host = os.environ.get('IMAP_HOST', 'in.postassl.it')
        imap_port = int(os.environ.get('IMAP_PORT', '993'))
        imap_user = os.environ.get('IMAP_USER', 'info@dms.associates')
        imap_pass = os.environ['IMAP_PASS']
        
        def decode_mime_words(s):
            """Decodifica le parole MIME nell'header"""
            return ''.join(
                word.decode(encoding or 'utf-8') if isinstance(word, bytes) else word
                for word, encoding in decode_header(s)
            )
        
        def extract_token_from_subject(subject):
            """Estrae informazioni del token dall'oggetto email"""
            # Cerca pattern come "DMS Security", "Token", etc.
            if 'dms' in subject.lower() and 'security' in subject.lower():
                return True
            return False
        
        def load_whitelist():
            """Carica la whitelist esistente"""
            try:
                with open('landing/viewer/whitelist.json', 'r') as f:
                    return json.load(f)
            except FileNotFoundError:
                return {"entries": [], "last_updated": None, "version": "1.0"}
        
        def save_whitelist(whitelist):
            """Salva la whitelist aggiornata"""
            whitelist['last_updated'] = datetime.now().isoformat()
            with open('landing/viewer/whitelist.json', 'w') as f:
                json.dump(whitelist, f, indent=2)
        
        def load_sessions_status():
            """Carica lo stato delle sessioni"""
            try:
                with open('landing/viewer/sessions_status.json', 'r') as f:
                    return json.load(f)
            except FileNotFoundError:
                return {"sessions": [], "last_updated": None, "version": "1.0"}
        
        def save_sessions_status(sessions_status):
            """Salva lo stato delle sessioni aggiornato"""
            sessions_status['last_updated'] = datetime.now().isoformat()
            with open('landing/viewer/sessions_status.json', 'w') as f:
                json.dump(sessions_status, f, indent=2)
        
        def update_session_status(email_addr, status="active"):
            """Aggiorna lo stato di una sessione specifica"""
            sessions_status = load_sessions_status()
            
            # Trova e aggiorna la sessione
            for session in sessions_status['sessions']:
                if session.get('email') == email_addr:
                    session['status'] = status
                    session['replied'] = True
                    session['activated'] = datetime.now().isoformat()
                    break
            else:
                # Se non trovata, crea nuova entry
                sessions_status['sessions'].append({
                    "email": email_addr,
                    "status": status,
                    "replied": True,
                    "activated": datetime.now().isoformat()
                })
            
            save_sessions_status(sessions_status)
            return sessions_status
        
        def add_to_whitelist(email_addr, duration_hours=1):
            """Aggiunge un'email alla whitelist"""
            whitelist = load_whitelist()
            
            # Calcola scadenza
            expires = datetime.now() + timedelta(hours=duration_hours)
            
            # Genera JTI univoco
            jti = f"reply_{int(datetime.now().timestamp())}_{hash(email_addr) % 10000}"
            
            # Crea entry
            entry = {
                "email": email_addr,
                "jti": jti,
                "added": datetime.now().isoformat(),
                "expires": int(expires.timestamp()),
                "source": "email_reply",
                "status": "active"
            }
            
            # Rimuovi eventuali entry esistenti per la stessa email
            whitelist['entries'] = [e for e in whitelist['entries'] if e.get('email') != email_addr]
            
            # Aggiungi nuova entry
            whitelist['entries'].append(entry)
            
            save_whitelist(whitelist)
            return entry
        
        try:
            print(f"ğŸ”— Connessione al server IMAP {imap_host}:{imap_port}...")
            mail = imaplib.IMAP4_SSL(imap_host, imap_port)
            mail.login(imap_user, imap_pass)
            mail.select('INBOX')
            
            # Cerca email degli ultimi 30 minuti
            since_date = (datetime.now() - timedelta(minutes=30)).strftime('%d-%b-%Y')
            
            print(f"ğŸ” Ricerca email dal {since_date}...")
            status, messages = mail.search(None, f'SINCE {since_date}')
            
            if status != 'OK':
                print("âŒ Errore nella ricerca email")
                exit(1)
            
            email_ids = messages[0].split()
            print(f"ğŸ“§ Trovate {len(email_ids)} email")
            
            processed_count = 0
            
            for email_id in email_ids[-10:]:  # Controlla solo le ultime 10 email
                try:
                    status, msg_data = mail.fetch(email_id, '(RFC822)')
                    if status != 'OK':
                        continue
                    
                    # Parse email
                    email_message = email.message_from_bytes(msg_data[0][1])
                    
                    # Estrai informazioni
                    subject = decode_mime_words(email_message.get('Subject', ''))
                    from_addr = decode_mime_words(email_message.get('From', ''))
                    date_str = email_message.get('Date', '')
                    
                    # Estrai solo l'indirizzo email
                    email_match = re.search(r'[\w\.-]+@[\w\.-]+\.\w+', from_addr)
                    sender_email = email_match.group(0) if email_match else from_addr
                    
                    print(f"ğŸ“¨ Email da: {sender_email}")
                    print(f"ğŸ“ Oggetto: {subject}")
                    
                    # Controlla se Ã¨ una risposta al nostro sistema
                    is_dms_reply = (
                        extract_token_from_subject(subject) or
                        'dms' in subject.lower() or
                        'security' in subject.lower() or
                        'accesso' in subject.lower()
                    )
                    
                    if is_dms_reply:
                        print(f"âœ… Rilevata risposta DMS da {sender_email}")
                        
                        # Aggiungi alla whitelist
                        entry = add_to_whitelist(sender_email, duration_hours=1)
                        
                        # Aggiorna stato sessione
                        update_session_status(sender_email, "active")
                        
                        print(f"ğŸ” Aggiunto alla whitelist:")
                        print(f"   Email: {entry['email']}")
                        print(f"   JTI: {entry['jti']}")
                        print(f"   Scadenza: {datetime.fromtimestamp(entry['expires']).strftime('%d/%m/%Y %H:%M')}")
                        print(f"ğŸ“Š Stato sessione aggiornato: {sender_email} -> active")
                        
                        processed_count += 1
                    
                except Exception as e:
                    print(f"âš ï¸ Errore elaborazione email {email_id}: {str(e)}")
                    continue
            
            mail.close()
            mail.logout()
            
            print(f"âœ… Elaborazione completata: {processed_count} risposte processate")
            
            if processed_count > 0:
                print("ğŸ“ Whitelist aggiornata con successo")
            else:
                print("â„¹ï¸ Nessuna nuova risposta da processare")
                
        except Exception as e:
            print(f"âŒ Errore durante il polling: {str(e)}")
            exit(1)
        EOF
        
    - name: ğŸ“¤ Commit changes
      if: success()
      run: |
        # Configura git per il commit automatico
        git config user.name "DMS Email Security Bot"
        git config user.email "action@github.com"
        
        # Controlla se ci sono modifiche
        if git diff --quiet landing/viewer/whitelist.json landing/viewer/sessions_status.json; then
          echo "â„¹ï¸ Nessuna modifica ai file di stato"
        else
          git add landing/viewer/whitelist.json landing/viewer/sessions_status.json
          git commit -m "ğŸ” Auto-update whitelist and sessions from email replies - $(date)"
          git push
          echo "âœ… Whitelist e stato sessioni aggiornati e committati"
        fi
        
    - name: ğŸ“Š Summary
      run: |
        echo "ğŸ“¬ Polling email completato"
        echo "ğŸ•’ Timestamp: $(date)"
        echo "ğŸ“ Whitelist: landing/viewer/whitelist.json"
